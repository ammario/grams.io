import type { NextPage } from "next";
import { useEffect, useMemo, useState } from "react";
import { useRouter } from "next/router";
import "../node_modules/react-vis/dist/style.css";
import {
  Crosshair,
  FlexibleXYPlot,
  HorizontalGridLines,
  LineSeries,
  VerticalGridLines,
  XAxis,
  YAxis,
} from "react-vis";
import { unit } from "mathjs";
import Add from "@mui/icons-material/Add";
import { CopyAll } from "@mui/icons-material";
import IngestionInput, {
  DrugColor,
  Ingestion,
} from "../components/IngestionInput";
import Footer from "../components/Footer";
import Intro from "../components/Intro";
import { SteadyState } from "../components/SteadyState";
import { tryParseDuration } from "../utils/parse";

const urlDelimiter = "-";

const encodeIngestionURL = (is: Ingestion[]) => {
  const params = new URLSearchParams();
  is.forEach((i) => {
    i.offset = i.offset.replace(urlDelimiter, "");
    i.drugName = i.drugName.replace(urlDelimiter, "");
    i.dosage = i.dosage.replace(urlDelimiter, "");
    i.halfLife = i.halfLife.replace(urlDelimiter, "");
    params.append(
      "i",
      `${i.offset}${urlDelimiter}${i.drugName}${urlDelimiter}${i.dosage}${urlDelimiter}${i.halfLife}`
    );
  });
  console.log("url encoded as", params.toString());
  return params;
};

const decodeIngestionURL = (params: URLSearchParams): Ingestion[] => {
  return params.getAll("i").map((v) => {
    const tokens = v.split(urlDelimiter);
    return {
      offset: tokens[0],
      drugName: tokens[1],
      dosage: tokens[2],
      halfLife: tokens[3],
      id: Math.random().toString(),
    };
  });
};

const emptyIngestion = (): Ingestion => {
  return {
    offset: "0min",
    drugName: "",
    halfLife: "",
    dosage: "",
    id: Math.random().toString(),
  };
};

interface parsedIngestion {
  offset: number;
  drugName: string;
  halfLife: number;
  dosage: number;
}

interface point {
  x: number;
  y: number;
}

const plotInterval = 0.1;

// ingestionEndpoint calculates the time by which less than 1/33 of original dose
// still resides in the ingester.
const ingestionEndpoint = (i: parsedIngestion): number => {
  return i.halfLife * Math.log2(33) + i.offset;
};

// plotIngestion returns 1000 points representing the metabolism of the ingestion.
const plotIngestion = (i: parsedIngestion, endPoint: number): point[] => {
  // The amount of hours by which less than 1/33 of the original dose is present.
  let points: point[] = [];
  for (let x = 0; x <= endPoint; x += plotInterval) {
    if (x < i.offset) {
      points.push({
        x: x,
        y: 0,
      });
      continue;
    }
    points.push({
      x: x,
      y: i.dosage / Math.pow(2, (x - i.offset) / i.halfLife),
    });
  }

  // Round for clean merging later.
  points.forEach((point, index) => {
    points[index].x = Math.round(point.x * 10) / 10;
  });
  return points;
};

// mergeLines is a PITA function that combines two lines generated by plotIngestion.
const mergeLines = (a: point[], b: point[]): point[] => {
  let c = new Map<number, number>([]);
  const merge = (vs: point[]) => {
    vs.forEach((v) => {
      if (c.has(v.x)) {
        c.set(v.x, (c.get(v.x) as number) + v.y);
        return;
      }
      c.set(v.x, v.y);
    });
  };
  merge(a);
  merge(b);
  return Array.from(c, ([x, y]): point => {
    return { x: x, y: y };
  }).sort((a, b) => {
    if (a.x > b.x) {
      return 1;
    }
    if (a.x < b.x) {
      return -1;
    }
    return 0;
  });
};

setTimeout(() => {
  if (typeof window === "undefined") {
    console.error("no window?");
    return null;
  }
  // The graph sometimes doesn't render until the page is resized or the lines are edited.
  // This is a janky solution to fix it.
  window.dispatchEvent(new Event("resize"));
}, 100);

const Home: NextPage = () => {
  const router = useRouter();
  // TODO: store the state in the URL
  const [ingestions, setIngestions] = useState<Ingestion[]>(() => {
    console.log(router.query.toString());
    if (typeof window === "undefined") {
      // I have no idea how to grab URL params within a useState with NextJS.
      return [emptyIngestion()];
    }

    try {
      const ingestions = decodeIngestionURL(
        new URLSearchParams(window.location.search)
      );
      console.log("ingestions from URL", ingestions);
      return ingestions;
    } catch (e) {
      console.log("oops at the url", e);
      return [emptyIngestion()];
    }
  });

  useEffect(() => {
    try {
      const url = {
        query: encodeIngestionURL(ingestions).toString(),
      };
      router.replace(url, undefined, { shallow: true });
      console.log("new url", JSON.stringify(url));
    } catch {
      return;
    }
  }, [ingestions, router]);

  const [crosshair, setCrosshair] = useState<
    {
      x: number;
      y: number;
      name: string;
    }[]
  >();

  const parsedIngestions = useMemo(
    () =>
      ingestions
        .map((ingestion): parsedIngestion | undefined => {
          const parseIngestion = (i: Ingestion): parsedIngestion => {
            const dosage = tryParseDuration(i.dosage, "mg");
            const halfLife = tryParseDuration(i.halfLife, "hours");
            if (halfLife > 30 * 30) {
              throw "Half life is too long (the application will crash!)";
            }
            const offset = tryParseDuration(i.offset, "hours");
            return {
              drugName: i.drugName,
              dosage: dosage,
              halfLife: halfLife,
              offset: offset,
            };
          };

          try {
            return parseIngestion(ingestion);
          } catch (e) {
            console.log("recoverable ingestion parse exception", e);
            return undefined;
          }
        })
        .filter(
          (v) => v && !isNaN(v.dosage) && !isNaN(v.halfLife)
        ) as parsedIngestion[],
    [ingestions]
  );

  const startingDoses = useMemo(() => {
    const startingDoses = new Map<string, number>();
    parsedIngestions.forEach((ingestion) => {
      const existingDose = startingDoses.get(ingestion.drugName) || 0;
      const newDose = existingDose + ingestion.dosage;
      startingDoses.set(ingestion.drugName, newDose);
      console.log("set starting dose", ingestion.drugName, newDose);
    });
    return startingDoses;
  }, [parsedIngestions]);

  const [normalizeDosages, setNormalizeDosages] = useState(() => {
    return false;
  });

  const graphData = useMemo((): JSX.Element => {
    const mergedIngestions = new Map<string, parsedIngestion>([]);
    const lines = new Map<string, point[]>([]);

    // Find maximum graph endpoint so all lines have equal resolution.
    const graphEndpoint = parsedIngestions
      .map((i) => ingestionEndpoint(i))
      .reduce((a, b) => Math.max(a, b), 0);

    parsedIngestions.forEach((ingestion) => {
      if (!mergedIngestions.has(ingestion.drugName)) {
        lines.set(ingestion.drugName, plotIngestion(ingestion, graphEndpoint));
        mergedIngestions.set(ingestion.drugName, ingestion);
        return;
      }
      const aLine = lines.get(ingestion.drugName) as point[];
      const bLine = plotIngestion(ingestion, graphEndpoint);
      console.log("a", aLine, "b", bLine);
      lines.set(ingestion.drugName, mergeLines(aLine, bLine));
    });

    const normalizedLines = new Map<string, point[]>([]);
    Array.from(lines).forEach(([name, points]) => {
      normalizedLines.set(
        name,
        points.map((ps) => {
          return {
            x: ps.x,
            y: ps.y / startingDoses.get(name)!,
          };
        })
      );
    });

    return (
      <div className="w-full h-2/3">
        <div className={"flex max-w-fit"}>
          <input
            checked={normalizeDosages}
            onChange={(e) => {
              setNormalizeDosages(e.target.checked);
            }}
            type={"checkbox"}
          />{" "}
          <span style={{ fontSize: "10px" }}>Normalize dosages</span>
        </div>
        <FlexibleXYPlot margin={{ left: 50 }}>
          <XAxis title={"Time"} tickFormat={(v) => `${v}h`} />
          <YAxis title={"Residuals (mg)"} />
          <VerticalGridLines />
          <HorizontalGridLines />
          {Array.from(lines, ([name, line], k) => {
            return (
              <LineSeries
                key={name}
                onNearestX={(e, { index }) => {
                  // The first line is responsible for setting the cross for every line.
                  if (k > 0) {
                    return;
                  }

                  setCrosshair(
                    Array.from(lines).map(([name, line]) => {
                      // Each line is guaranteed to have a point at the same index.
                      return {
                        x: e.x,
                        y: line[index].y,
                        name: name,
                      };
                    })
                  );
                }}
                color={DrugColor.hex(name)}
                data={normalizeDosages ? normalizedLines.get(name) : line}
                opacity={1}
              />
            );
          })}
          {typeof crosshair !== "undefined" && (
            <Crosshair
              values={crosshair}
              style={{
                line: {
                  background: "rgba(0, 0, 0, 0.17)",
                  width: "3px",
                },
              }}
              titleFormat={(ps) => {
                console.log(ps);
                return { title: "Time", value: `${ps[0].x}h` };
              }}
              itemsFormat={(ps) => {
                return ps.map((pt: point, index: number) => {
                  const startDose = startingDoses.get(
                    crosshair[index].name
                  ) as number;
                  console.log("starty", startDose);
                  const residual = pt.y;
                  const percentRemaining = Math.round(
                    (residual * 100) / startDose
                  ).toPrecision(2);
                  return {
                    title: crosshair[index].name,
                    value: `${residual.toPrecision(
                      3
                    )}mg (${percentRemaining}%)`,
                  };
                });
              }}
            />
          )}
        </FlexibleXYPlot>
      </div>
    );
  }, [parsedIngestions, crosshair, startingDoses, normalizeDosages]);

  if (typeof window === "undefined") {
    console.error("no window?");
    return null;
  }

  return (
    <div className="h-screen w-screen flex flex-col md:container md:mx-auto p-3 md:py-10">
      <Intro />
      <div id="ingestions" className="container pt-6 px-0">
        <div className={"ingest-container grid gap-4 mb-1"}>
          <span>Offset</span>
          <span>Drug name</span>
          <span>Dosage</span>
          <span>Half-life</span>
          <span> </span>
        </div>
        {ingestions.map((ingestion, index) => {
          return (
            <IngestionInput
              key={ingestion.id}
              ingestion={ingestion}
              edit={(e) => {
                const newIngestions = [...ingestions];
                // Trash if undefined.
                if (e === undefined) {
                  newIngestions.splice(index, 1);
                  console.log(
                    "trash",
                    JSON.stringify(ingestions),
                    JSON.stringify(newIngestions)
                  );
                } else {
                  newIngestions[index] = {
                    ...ingestion,
                    ...e,
                  };
                }

                setIngestions(newIngestions);
              }}
            />
          );
        })}

        <div className={"flex justify-between py-4"}>
          <button
            className="flex items-center"
            onClick={() => setIngestions([...ingestions, emptyIngestion()])}
          >
            <Add className="mr-1" />
            Add Ingestion
          </button>

          <button
            onClick={() => {
              navigator.clipboard.writeText(window.location.toString());
            }}
          >
            <CopyAll className="mr-1" />
            Copy URL
          </button>
        </div>
      </div>
      <div id="results" className="container py-2 px-0 flex-1 flex flex-col">
        <SteadyState />
        <div className="flex">
          <h2>Decay graph</h2>
        </div>
        <hr className="mb-4 mt-1" />
        {graphData}
      </div>

      <Footer />
    </div>
  );
};

export default Home;
